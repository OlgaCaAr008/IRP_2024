# -*- coding: utf-8 -*-
"""4layers.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1auXKoCob5hQrwar7SPYI0Xti1dqE3WxE
"""

import os
from google.colab import drive
drive.mount('/content/drive')
project_folder = '/content/drive/My Drive/Colab Notebooks/ARCHER2_RUNS/results' # working folder path
os.chdir(project_folder) # changing the path

import numpy as np
from scipy.ndimage import distance_transform_edt
import tensorflow as tf
from tensorflow.keras.callbacks import EarlyStopping
from tensorflow.keras import layers, models, regularizers

field = np.load('field.npy') # n x Ny x Nx x 3
geometry = np.load('geo.npy') # n x Ny x Nx

vx = field[:,:,:,1] # n x Ny x Nx
vy = field[:,:,:,2] # n x Ny x Nx
rho = field[:,:,:,0]

# Neural Network

input_layer = layers.Input(shape=(geometry.shape[1], geometry.shape[2], 1))

# Conv 1
x = layers.Conv2D(32, (3, 3), activation='relu', padding='same')(input_layer)
x = layers.MaxPooling2D((2, 2))(x)

# Conv 2
x = layers.Conv2D(64, (3, 3), activation='relu', padding='same')(x)
x = layers.MaxPooling2D((2, 2))(x)

# Conv 3
x = layers.Conv2D(128, (3, 3), activation='relu', padding='same')(x)
x = layers.MaxPooling2D((2, 2))(x)

# Conv 4
x = layers.Conv2D(256, (3, 3), activation='relu', padding='same')(x)
x = layers.MaxPooling2D((2, 2))(x)

# Flatten the output to feed into the dense layers
x = layers.Flatten()(x)
x = layers.Dense(256, activation='relu')(x)

# Output layers for the x and y components of the velocity
output_x = layers.Dense(vx.shape[1] * vx.shape[2], activation='linear', name='velocity_x')(x)
output_y = layers.Dense(vy.shape[1] * vy.shape[2], activation='linear', name='velocity_y')(x)
output_rho = layers.Dense(rho.shape[1] * rho.shape[2], activation='linear', name='density')(x)

# Create the model
model = models.Model(inputs=input_layer, outputs=[output_x, output_y, output_rho])

from tensorflow import keras

# Assuming 'model' is already defined and compiled

# Enhanced model plot with additional details
keras.utils.plot_model(
    model,
    to_file="ARCH_.png",  # Save the diagram to a file
    show_shapes=True,           # Show input and output shapes for each layer
    expand_nested=True,         # Expand nested models into clusters
    dpi=300                      # Set the resolution of the image
)

model.summary()

early_stopping = EarlyStopping(monitor='val_loss', patience=500, verbose=1, restore_best_weights=True)

model.compile(
    optimizer='adam',
    loss='mean_squared_error',
    metrics={'velocity_x': ['mae'], 'velocity_y': ['mae'], 'density' : ['mae']}
)

Input_data = geometry.reshape((geometry.shape[0], geometry.shape[1], geometry.shape[2], 1))
Vx_data = vx.reshape((vx.shape[0], vx.shape[1] * vx.shape[2]))
Vy_data = vy.reshape((vy.shape[0], vy.shape[1] * vy.shape[2]))
Rho_data = rho.reshape((rho.shape[0], rho.shape[1] * rho.shape[2]))

np.random.seed(42)  # For reproducibility
indices = np.arange(Input_data.shape[0])
np.random.shuffle(indices)

train_size = int(0.8 * len(indices))
train_indices = indices[:train_size]
test_indices = indices[train_size:]

Input_train = Input_data[train_indices]
Input_test = Input_data[test_indices]

Vx_train = Vx_data[train_indices]
Vx_test = Vx_data[test_indices]

Vy_train = Vy_data[train_indices]
Vy_test = Vy_data[test_indices]

Rho_train = Rho_data[train_indices]
Rho_test = Rho_data[test_indices]

history = model.fit(Input_train, {'velocity_x': Vx_train, 'velocity_y': Vy_train, 'density':Rho_train}, epochs=10000, batch_size=32, validation_split=0.2, callbacks=[early_stopping])

train_loss = history.history['loss'][-1]
val_loss = history.history['val_loss'][-1]
test_loss = model.evaluate(Input_test, [Vx_test, Vy_test, Rho_test])

np.save('train_loss4.npy', train_loss)
np.save('val_loss4.npy', val_loss)
np.save('test_loss4.npy', test_loss[0])

stopped_epoch = early_stopping.stopped_epoch
print("Training was stopped at epoch -4:", stopped_epoch)