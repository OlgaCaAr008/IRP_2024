# -*- coding: utf-8 -*-
"""CNN.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1A5JUlQNxseoPgNYjkLyC5Rb7UJC3Zdol
"""

import os
from google.colab import drive
drive.mount('/content/drive')
project_folder = '/content/drive/My Drive/Colab Notebooks/ARCHER2_RUNS/results' # working folder path
os.chdir(project_folder) # changing the path

import numpy as np
from scipy.ndimage import distance_transform_edt
import tensorflow as tf
from tensorflow.keras import layers, models
from sklearn.model_selection import train_test_split

geometry = np.load('all_geometries.npy') # (n, 450, 500)
field = np.load('all_fields.npy') # (n, 450, 500,3)

def resize_data(geometry, field, factor):
    # New dimensions
    newNy = geometry.shape[1] // factor
    newNx = geometry.shape[2] // factor

    # Initialize arrays
    geometry_re = np.empty((geometry.shape[0], newNy, newNx), dtype=bool)
    field_re = np.empty((field.shape[0], newNy, newNx, 3), dtype=np.float64)

    for i in range(geometry.shape[0]):
        resized_geom = tf.image.resize(tf.cast(geometry[i], tf.float32)[tf.newaxis, :, :, tf.newaxis],[newNy, newNx], method='nearest')
        geometry_re[i] = tf.cast(tf.squeeze(resized_geom, axis=[0, 3]), tf.bool).numpy()

        resized_field = tf.image.resize(field[i][tf.newaxis, :, :, :],[newNy, newNx], method='bilinear')
        field_re[i] = resized_field[0].numpy()

    return geometry_re, field_re

def binary_to_sdf(binary_image):
    dist_out = distance_transform_edt(1 - binary_image)  # Background
    dist_in = distance_transform_edt(binary_image)       # Foreground
    sdf = dist_out - dist_in
    return sdf

factor = 2  # Resize factor
geometry, field = resize_data(geometry, field, factor)
sdf_array = np.zeros_like(geometry, dtype=float)

for i in range(geometry.shape[0]):
  sdf_array[i] = binary_to_sdf(geometry[i])

geometry = sdf_array

def build_cnn_model(Ny, Nx):
    input_shape = (Ny, Nx, 1)  # Define input shape dynamically based on Ny and Nx

    inputs = layers.Input(shape=input_shape)

    # Encoder
    x = layers.Conv2D(16, (3, 3), padding='same', activation='relu')(inputs)
    x = layers.Conv2D(512, (3, 3), padding='same', activation='relu')(x)

    # Decoder
    x = layers.Conv2DTranspose(545, (3, 3), padding='same', activation='relu')(x)
    x = layers.Conv2DTranspose(16, (3, 3), padding='same', activation='relu')(x)


    # Output, 3 channels: density, x-velocity, and y-velocity
    outputs = layers.Conv2D(3, (1, 1), padding='same', activation='linear')(x)

    # Create and compile the model
    model = models.Model(inputs=inputs, outputs=outputs)
    model.compile(optimizer='adam', loss='mse', metrics=['accuracy'])
    return model


Ny, Nx = geometry.shape[1], geometry.shape[2]  # Can be set dynamically based on your data dimensions
model = build_cnn_model(Ny, Nx)
#model.summary()

# Include channel
geometry2 = np.expand_dims(geometry, -1)  # Assuming geometry loaded correctly

geometry_train, geometry_test, field_train, field_test = train_test_split(geometry, field, test_size=0.2)

model.fit(geometry_train, field_train, batch_size=32, epochs=200, validation_split=0.2)

# Evaluate the model on the test data
test_loss, test_acc = model.evaluate(geometry_test, field_test, verbose=2)
print(f"Test Loss: {test_loss}, Test Accuracy: {test_acc}")

import matplotlib.pyplot as plt

# Predict the fields using the test geometry
predicted_fields = model.predict(geometry_test)

# Select a random example to visualize
example_index = np.random.randint(0, len(geometry_test))
actual_field = field_test[example_index]
predicted_field = predicted_fields[example_index]

fig, axes = plt.subplots(1, 3, figsize=(15, 5))
axes[0].imshow(actual_field[:,:,1], cmap='viridis', interpolation='nearest')
axes[0].set_title('Actual Density')
axes[1].imshow(predicted_field[:,:,1], cmap='viridis', interpolation='nearest')
axes[1].set_title('Predicted Density')
axes[2].imshow(actual_field[:,:,1] - predicted_field[:,:,1], cmap='viridis', interpolation='nearest')
axes[2].set_title('Difference in Density')
plt.show()
